package dev.tommasop1804.kutils.classes.identifiers

import com.fasterxml.jackson.core.JsonGenerator
import com.fasterxml.jackson.core.JsonParser
import com.fasterxml.jackson.databind.JsonDeserializer
import com.fasterxml.jackson.databind.JsonSerializer
import com.fasterxml.jackson.databind.SerializerProvider
import dev.tommasop1804.kutils.BigInt
import dev.tommasop1804.kutils.Instant
import dev.tommasop1804.kutils.exceptions.MalformedInputException
import dev.tommasop1804.kutils.get
import dev.tommasop1804.kutils.invoke
import dev.tommasop1804.kutils.toBigInt
import jakarta.persistence.AttributeConverter
import org.hibernate.engine.spi.SharedSessionContractImplementor
import org.hibernate.type.SqlTypes
import org.hibernate.usertype.EnhancedUserType
import tools.jackson.databind.DeserializationContext
import tools.jackson.databind.SerializationContext
import tools.jackson.databind.ValueDeserializer
import tools.jackson.databind.ValueSerializer
import tools.jackson.databind.annotation.JsonDeserialize
import tools.jackson.databind.annotation.JsonSerialize
import java.io.Serializable
import java.lang.management.ManagementFactory
import java.net.InetAddress
import java.net.UnknownHostException
import java.nio.charset.StandardCharsets
import java.security.MessageDigest
import java.security.NoSuchAlgorithmException
import java.security.SecureRandom
import java.sql.PreparedStatement
import java.sql.ResultSet
import java.time.Instant
import java.util.*
import java.util.stream.IntStream
import kotlin.math.pow
import kotlin.text.startsWith
import kotlin.time.ExperimentalTime


/**
 * Represents a class for generating and managing CUIDs (Collision-Resistant Unique Identifiers).
 *
 * The `CUID` class provides functionality for creating, representing, and working
 * with unique identifiers. Fields such as `value`, `version`, `timestamp`, and `instant`
 * help define essential properties of the CUID. Overridden methods like `toString`,
 * `equals`, and `hashCode` allow for precise control over how instances are represented
 * and compared, while methods like `chars` and `codePoints` provide access to
 * character and Unicode point sequences based on the instance value.
 *
 * @property value The string representation of the CUID.
 * @property version The version associated with the CUID.
 * @property timestamp The timestamp when the CUID was created or last updated.
 * @property instant The instant of time associated with the CUID.
 * @since 1.0.0
 * @author Tommaso Pastorelli
 */
@JsonSerialize(using = CUID.Companion.Serializer::class)
@JsonDeserialize(using = CUID.Companion.Deserializer::class)
@com.fasterxml.jackson.databind.annotation.JsonSerialize(using = CUID.Companion.OldSerializer::class)
@com.fasterxml.jackson.databind.annotation.JsonDeserialize(using = CUID.Companion.OldDeserializer::class)
@Suppress("unused", "kutils_take_as_int_invoke")
class CUID(val value: String, val version: CUIDVersion = identifyVersion(value), private val savedTimestamp: Long? = null) : CharSequence by value, Serializable {
    /**
     * Provides the timestamp value associated with this CUID instance.
     *
     * The timestamp is extracted from the CUID when it adheres to the CUIDv1 standard.
     * It represents the time at which the CUID was generated and is encoded as the first
     * eight characters (base-36) of the `value` property.
     *
     * For CUID instances with version CUIDv2, the timestamp is only available if it was
     * generated using this class and saved at the time of creation. If the `savedTimestamp`
     * is not present for a CUIDv2 instance, accessing this property throws an
     * `UnsupportedOperationException` since CUIDv2 does not encode a timestamp by design.
     *
     * @throws UnsupportedOperationException if the version is CUIDv2 and the timestamp
     * was not generated by this class or does not exist.
     * @return The numeric timestamp in base 10 extracted from the CUID, or `savedTimestamp` for applicable CUIDv2 instances.
     * @since 1.0.0
     */
    val timestamp: Long
        get() = if (version == CUIDVersion.CUIDv2)
            savedTimestamp ?: throw UnsupportedOperationException("The timestamp property is not available for CUIDv2 not generated with this class")
        else value[1..<9].toLong(BASE)

    /**
     * Provides an `Instant` representation of the timestamp stored in the current instance.
     *
     * The `instant` value is derived by converting the epoch millisecond timestamp into
     * an `Instant`.
     *
     * @return The `Instant` corresponding to the epoch millisecond timestamp.
     * @throws UnsupportedOperationException if the version is CUIDv2 and the timestamp
     * was not generated by this class or does not exist.
     * @since 1.0.0
     */
    val instant: Instant
        get() = Instant(timestamp)

    /**
     * Initializes a new instance of the CUID class by constructing a unique identifier
     * using a combination of a predefined letter, timestamp, counter, fingerprint,
     * and random blocks. The generated value is guaranteed to be unique within the
     * context of the application due to its structure and components.
     *
     * The composed value has the following structure:
     * - A predefined static letter constant indicating the type of identifier.
     * - A timestamp in base-36 format for temporal uniqueness.
     * - A padded counter value to handle high-frequency ID generations within the same timestamp.
     * - A static fingerprint value identifying the environment generating the ID.
     * - Two random blocks of base-36 values for added randomness and uniqueness.
     *
     * @since 1.0.0
     */
    constructor(version: CUIDVersion = CUIDVersion.CUIDv1, timestamp: Instant? = null, lengthForV2: Int = LENGTH_V2) : this(when (version) {
        CUIDVersion.CUIDv1 -> generateV1(timestamp?.toEpochMilli())
        CUIDVersion.CUIDv2 -> generateV2(timestamp?.toEpochMilli(), lengthForV2)
    }, version, Instant().toEpochMilli())

    /**
     * Initializes a new instance of the CUID class by constructing a unique identifier
     * using a combination of a predefined letter, timestamp, counter, fingerprint,
     * and random blocks. The generated value is guaranteed to be unique within the
     * context of the application due to its structure and components.
     *
     * The composed value has the following structure:
     * - A predefined static letter constant indicating the type of identifier.
     * - A timestamp in base-36 format for temporal uniqueness.
     * - A padded counter value to handle high-frequency ID generations within the same timestamp.
     * - A static fingerprint value identifying the environment generating the ID.
     * - Two random blocks of base-36 values for added randomness and uniqueness.
     *
     * @since 1.0.0
     */
    @OptIn(ExperimentalTime::class)
    constructor(version: CUIDVersion = CUIDVersion.CUIDv1, timestamp: kotlin.time.Instant? = null, lengthForV2: Int = LENGTH_V2) : this(when (version) {
        CUIDVersion.CUIDv1 -> generateV1(timestamp?.toEpochMilliseconds())
        CUIDVersion.CUIDv2 -> generateV2(timestamp?.toEpochMilliseconds(), lengthForV2)
    }, version, Instant().toEpochMilli())

    init {
        value.isValidCUID(version) || throw MalformedInputException("The string is not a valid CUID")
    }

    companion object {
        /**
         * A constant value representing the alphabet for CUIDv2.
         * @since 1.0.0
         */
        private const val ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz"
        /**
         * A constant value representing the base used for numerical conversions
         * or encoding operations within the CUID implementation.
         *
         * This value is set to 36, which is commonly used for alphanumeric representations.
         *
         * @since 1.0.0
         */
        private const val BASE = 36
        /**
         * Represents the fixed length for the unique identifier generation within the CUID implementation.
         * This value determines the number of characters in the identifier.
         *
         * @since 1.0.0
         */
        private const val LENGTH_V1 = 25
        /**
         * The length constant for version 2 of the CUID format.
         * This value determines the fixed length used for CUIDs.
         *
         * @since 1.0.0
         */
        private const val LENGTH_V2 = 24
        /**
         * Represents the block size used for segmenting or processing data elements.
         * Often used as a fundamental building block size for handling fixed-size units.
         *
         * @since 1.0.0
         */
        private const val BLOCK_SIZE = 4
        /**
         * Represents the number of possible discrete values determined by raising the base to the power
         * of the block size. This value is precomputed for performance optimization and used in
         * operations that depend on the size of the discrete value space.
         *
         * @since 1.0.0
         */
        private val DISCRETE_VALUES = BASE.toDouble().pow(BLOCK_SIZE)
        /**
         * Represents a constant letter used in the CUID class.
         * This value is immutable and is designed to be utilized internally
         * within the class for various identification or processing purposes.
         *
         * @since 1.0.0
         */
        private const val LETTER = "c"
        /**
         * A regular expression pattern used to match any character that is not a letter (A-Z, a-z)
         * or a digit (0-9). This pattern is compiled and stored for efficient reuse in operations
         * that require matching or replacing such characters.
         *
         * @since 1.0.0
         */
        private val PATTERN_V1 = "[^A-Za-z0-9]".toPattern()
        /**
         * Compiled regular expression pattern that validates a specific string format.
         * This pattern ensures that the string starts with a lowercase letter followed
         * by alphanumeric characters without any special characters.
         *
         * @since 1.0.0
         */
        private val PATTERN_V2 = "^[a-z][a-z0-9]*$".toPattern()

        /**
         * A private variable used to store the current count value.
         * It is initialized to zero and is used internally for counting purposes.
         *
         * @since 1.0.0
         */
        private var counter1 = 0

        /**
         * A variable used to track the count or state for a specific purpose within the class.
         * Its exact functionality depends on the context of the class implementation.
         *
         * @since 1.0.0
         */
        private var counter2 = 0L

        /**
         * A private instance of `SecureRandom` used for generating cryptographically strong random values.
         * This ensures the randomness is suitable for security-critical operations.
         *
         * @since 1.0.0
         */
        private var RANDOM = SecureRandom()

        /**
         * Retrieves host information based on the runtime JVM configuration.
         * If the host or process information cannot be retrieved, it falls back to the provided fallback parameters.
         *
         * @param idFallback The fallback identifier to use if the JVM name is unavailable or invalid.
         * @return A string representing the host information in the format "id@name".
         * @since 1.0.0
         */
        private fun getHostInfo(idFallback: String): String {
            val jvmName = ManagementFactory.getRuntimeMXBean().name
            val index = jvmName.indexOf('@')
            if (index < 1) return String.format("%s@%s", idFallback, "dummy-host")
            return jvmName
        }

        /**
         * Computes a fingerprint based on host information, including host ID, host name,
         * and a series of arithmetic transformations of the host name characters. The
         * result is a concatenated string composed of processed host ID and host name blocks.
         *
         * @return A unique fingerprint string derived from host-specific details.
         * @since 1.0.0
         */
        private fun getFingerprint(version: CUIDVersion): String {
            if (version == CUIDVersion.CUIDv1) {
                val hostInfo = getHostInfo(Date().time.toString())
                val hostId = hostInfo.split("@")[0]
                val hostName = hostInfo.split("@")[1]

                var acc = hostName.length + BASE
                for (i in 0 until hostName.length)
                    acc += acc + hostName[i].code

                val idBlock = pad(hostId.toLong().toString(BASE), 2)
                val nameBlock = pad(acc.toString(), 2)
                return idBlock + nameBlock
            }

            val processId = ManagementFactory.getRuntimeMXBean().name
            val hostname = try {
                InetAddress.getLocalHost().hostName
            } catch (e: UnknownHostException) {
                "unknown-host"
            }
            return processId + hostname + Thread.currentThread().threadId()
        }

        /**
         * Pads the given string with leading zeros to ensure it reaches the specified length.
         *
         * @param str The input string to be padded.
         * @param len The desired length of the resulting string.
         * @return A string padded with leading zeros to match the specified length.
         * @since 1.0.0
         */
        private fun pad(str: String, len: Int): String {
            val repeatedZero = String(CharArray(len)).replace("\u0000", "0")
            val padded = repeatedZero + str
            return (-padded.length - len)(padded)
        }

        /**
         * Generates a random block of characters based on a discrete set of values and a specified base.
         * The result is padded to a uniform block size.
         *
         * @return A string representing a padded random block.
         * @since 1.0.0
         */
        private fun getRandomBlock(): String {
            return pad(
                (Math.random() * DISCRETE_VALUES).toLong().toString(BASE),
                BLOCK_SIZE
            )
        }

        /**
         * Safely increments and returns a counter value. If the counter value reaches
         * the defined limit, it resets the counter to zero to ensure it stays within
         * discrete values.
         *
         * @return the current counter value before incrementing.
         * @since 1.0.0
         */
        private fun safeCounter(): Int {
            counter1 = if (counter1 < DISCRETE_VALUES) counter1 else 0
            return counter1++
        }

        /**
         * Checks if the current string does not contain any special characters.
         * A special character is defined by the regular expression pattern used in the function.
         *
         * @receiver The string to be checked for special characters.
         * @return `true` if the string does not contain any special characters; otherwise, `false`.
         * @since 1.0.0
         */
        private fun CharSequence.hasNotSpecialChars() = !PATTERN_V1.matcher(this).find()

        /**
         * Generates a Version 1 CUID (Collision-resistant Unique Identifier) using components such as
         * a timestamp, a counter, a fingerprint, and random blocks. The resulting identifier is designed
         * to be human-readable, secure, and unique, suitable for general-purpose applications and distributed
         * environments.
         *
         * @param ts An optional timestamp in milliseconds to be included in the CUID generation.
         *           If null, the current time will be used.
         * @return A Version 1 CUID string.
         * @since 1.0.0
         */
        private fun generateV1(ts: Long?) =
            LETTER + (ts ?: Date().time.toString(BASE)) + pad(safeCounter().toString(BASE), BLOCK_SIZE) + getFingerprint(CUIDVersion.CUIDv1) + getRandomBlock() + getRandomBlock()

        /**
         * Generates a CUID (Collision-resistant Unique Identifier) v2 string.
         *
         * The generated identifier includes components such as a random first character,
         * a base-36 representation of a hashed input derived from the timestamp,
         * system fingerprint, counter, and additional random data.
         *
         * @param ts The timestamp to use for generating the identifier. If null, the current system time will be used.
         * @param length The desired length of the generated identifier. Defaults to LENGTH_V2.
         * @return A unique CUID v2 string of specified length.
         * @since 1.0.0
         */
        private fun generateV2(ts: Long?, length: Int = LENGTH_V2): String {
            val firstChar: Char = (-10)(ALPHABET)[RANDOM.nextInt((-10)(ALPHABET).length)]
            val timestamp = ts ?: System.currentTimeMillis()
            val count: Long = ++counter2
            val randomStr = toBase36(BigInt(128, RANDOM)) + toBase36(BigInt(128, RANDOM))
            val hashInput = (timestamp.toString() + getFingerprint(CUIDVersion.CUIDv2) + count.toString()) + randomStr
            val hash: String?
            try {
                val digest = MessageDigest.getInstance("SHA3-512")
                val hashBytes = digest.digest(hashInput.toByteArray(StandardCharsets.UTF_8))
                hash = toBase36(BigInt(1, hashBytes))
            } catch (e: NoSuchAlgorithmException) {
                throw RuntimeException("SHA3-512 not available", e)
            }

            return (firstChar.toString() + hash).take(length)
        }

        /**
         * Converts the given number to a Base36-encoded string using the predefined alphabet.
         *
         * @param number the number to be converted to Base36. Must be a non-negative value.
         * @return the Base36 representation of the input number as a string.
         * @since 1.0.0
         */
        private fun toBase36(number: BigInt): String {
            var number: BigInt = number
            val sb = StringBuilder()
            while (number > BigInt.ZERO) {
                val divRem: Array<BigInt?> = number.divideAndRemainder(ALPHABET.length.toBigInt())
                sb.insert(0, ALPHABET[divRem[1]!!.toInt()])
                number = divRem[0]!!
            }
            return sb.toString()
        }

        /**
         * Identifies the version of the given CUID string by analyzing its structure and characteristics.
         *
         * @param s The string representation of the CUID to be analyzed.
         * @return The `CUIDVersion` enum value indicating whether the input corresponds to CUIDv1 or CUIDv2.
         * @since 1.0.0
         */
        private fun identifyVersion(s: String): CUIDVersion {
            if (!PATTERN_V2.matcher(s).matches()) return CUIDVersion.CUIDv1
            if (s.startsWith("c") && s.length == LENGTH_V1 && s.hasNotSpecialChars()) return CUIDVersion.CUIDv1
            return CUIDVersion.CUIDv2
        }

        /**
         * Validates if the provided CUID string adheres to specific rules.
         * The method ensures the CUID has the required length, starts with the designated letter,
         * and contains no special characters.
         *
         * @param version the version to check
         * @return true if the CUID is valid; false otherwise
         * @since 1.0.0
         */
        fun CharSequence.isValidCUID(version: CUIDVersion) = when (version) {
            CUIDVersion.CUIDv1 -> length == LENGTH_V1 && take(1) == LETTER && hasNotSpecialChars()
            CUIDVersion.CUIDv2 -> PATTERN_V2.matcher(this).matches()
        }

        /**
         * Converts the `CharSequence` into a `CUID` instance by wrapping the conversion in a `Result`.
         * This allows safe handling of potential exceptions that may arise during the creation of a `CUID` object.
         *
         * @receiver The `CharSequence` to be converted into a `CUID`.
         * @return A `Result` wrapping the `CUID` instance upon successful conversion or an exception if the conversion fails.
         * @since 1.0.0
         */
        fun CharSequence.toCUID() = runCatching { CUID(toString()) }

        class Serializer : ValueSerializer<CUID>() {
            override fun serialize(value: CUID, gen: tools.jackson.core.JsonGenerator, ctxt: SerializationContext) {
                gen.writeString(value.value)
            }
        }

        class Deserializer : ValueDeserializer<CUID>() {
            override fun deserialize(p: tools.jackson.core.JsonParser, ctxt: DeserializationContext) = CUID(p.string, identifyVersion(p.string))
        }

        class OldSerializer : JsonSerializer<CUID>() {
            override fun serialize(value: CUID, gen: JsonGenerator, serializers: SerializerProvider) =
                gen.writeString(value.value)
        }

        class OldDeserializer : JsonDeserializer<CUID>() {
            override fun deserialize(p: JsonParser, ctxt: com.fasterxml.jackson.databind.DeserializationContext): CUID = CUID(p.text, identifyVersion(p.text))
        }

        @jakarta.persistence.Converter(autoApply = true)
        class Converter : AttributeConverter<CUID?, String?> {
            override fun convertToDatabaseColumn(attribute: CUID?): String? = attribute?.value
            override fun convertToEntityAttribute(dbData: String?): CUID? = dbData?.let { CUID(it, identifyVersion(it)) }
        }

        class Type : EnhancedUserType<CUID> {
            override fun getSqlType(): Int = SqlTypes.VARCHAR

            override fun returnedClass(): Class<CUID> = CUID::class.java

            override fun equals(
                x: CUID?,
                y: CUID?
            ): Boolean = x == y

            override fun hashCode(x: CUID?): Int = x?.hashCode() ?: 0

            override fun nullSafeGet(
                rs: ResultSet?,
                position: Int,
                session: SharedSessionContractImplementor?,
                owner: Any?
            ): CUID? {
                val value = rs?.getString(position) ?: return null
                return CUID(value, identifyVersion(value))
            }

            override fun nullSafeSet(
                st: PreparedStatement?,
                value: CUID?,
                index: Int,
                session: SharedSessionContractImplementor?
            ) {
                st?.setString(index, value?.value) ?: throw IllegalArgumentException("Statement cannot be null")
            }

            override fun deepCopy(value: CUID?): CUID? = value?.let { CUID(it.value, it.version) }

            override fun isMutable(): Boolean = false

            override fun disassemble(value: CUID?): Serializable? = deepCopy(value)

            override fun assemble(
                cached: Serializable?,
                owner: Any?
            ): CUID? = cached as? CUID

            override fun toSqlLiteral(value: CUID?): String? = value?.let { "'${it.value}'" }

            override fun toString(value: CUID?): String? = value?.value

            override fun fromStringValue(sequence: CharSequence?): CUID =
                sequence?.let { CUID(it.toString(), identifyVersion(it.toString())) } ?: throw IllegalArgumentException("Cannot convert null to CUID")
        }
    }

    /**
     * Returns a string representation of the object. This method overrides the default
     * implementation of `toString` to return the `value` associated with the instance.
     *
     * @return A `String` representing the `value` of the object.
     * @since 1.0.0
     */
    override fun toString() = value

    /**
     * Returns a stream of integer values representing the sequence of characters in the `value`.
     *
     * @return An `IntStream` of character values from the `value`.
     * @since 1.0.0
     */
    override fun chars(): IntStream = value.chars()

    /**
     * Returns a stream of Unicode code points associated with the value of this instance.
     *
     * @return An `IntStream` representing the sequence of Unicode code points in the value.
     * @since 1.0.0
     */
    override fun codePoints(): IntStream = value.codePoints()

    /**
     * Compares this instance with another object to determine equality.
     *
     * Two instances of `CUID` are considered equal if they have the same class type,
     * and their `value` and `version` properties are equal.
     *
     * @param other The object to compare with the current instance for equality.
     * @return `true` if the specified object is equal to the current instance; `false` otherwise.
     * @since 1.0.0
     */
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as CUID

        if (value != other.value) return false
        if (version != other.version) return false

        return true
    }

    /**
     * Computes the hash code for the current instance based on its fields.
     *
     * This method overrides the default `hashCode` implementation to provide a hash code
     * derived from the `value` and `version` properties of the class. It ensures objects
     * with the same `value` and `version` produce the same hash code.
     *
     * @return The computed hash code for the instance.
     * @since 1.0.0
     */
    override fun hashCode(): Int {
        var result = value.hashCode()
        result = 31 * result + version.hashCode()
        return result
    }
}

/**
 * Represents the different versions of CUID (Collision-resistant Unique Identifiers).
 * Each version is tailored for specific use cases and improvements over its predecessor.
 *
 * @since 1.0.0
 */
@Suppress("unused")
enum class CUIDVersion(val description: String) {
    /**
     * Enum value defining the CUID Version 1 (CUIDv1) standard.
     *
     * CUIDv1 is designed to produce identifiers that are:
     * - Human-readable, secure, and unique.
     * - Consist of components such as timestamps, counters, machine fingerprints, and random data.
     * - Distributed-environment compatible by ensuring uniqueness across multiple systems.
     *
     * This version emphasizes reliability and simplicity, making it suitable for general-purpose applications.
     *
     * @since 1.0.0
     */
    CUIDv1("Designed to be human-readable, secure, and unique even in distributed environments. Uses timestamps, counters, machine fingerprints, and random data."),
    /**
     * Represents the CUID version 2, which is an improved successor of CUID version 1.
     * It is shorter, faster, and designed with better collision management.
     * Well-suited for use in distributed frontend and backend systems.
     *
     * @since 1.0.0
     */
    CUIDv2("An improved successor: shorter, faster, and with better collision management. Well suited for distributed frontend/backends."),
}