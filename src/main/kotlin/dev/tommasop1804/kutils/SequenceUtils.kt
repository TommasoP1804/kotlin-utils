@file:JvmName("SequenceUtilsKt")
@file:Suppress("unused", "kutils_collection_declaration", "kutils_take_as_int_invoke", "kutils_drop_as_int_invoke")
@file:Since("1.0.0")

package dev.tommasop1804.kutils

import Break
import Continue
import dev.tommasop1804.kutils.annotations.Since
import dev.tommasop1804.kutils.classes.constants.SortDirection
import dev.tommasop1804.kutils.exceptions.TooManyElementsException
import kotlin.contracts.ExperimentalContracts
import kotlin.contracts.InvocationKind
import kotlin.contracts.contract


/**
 * Transforms a [Sequence] into a [Map] by applying the provided key and value mapping functions.
 *
 * @param key a function that defines how to transform each element of the sequence into a key.
 * @param value a function that defines how to transform each element of the sequence into a value.
 * @return a [Map] containing key-value pairs generated by applying the key and value functions
 *         to elements of the original sequence.
 * @since 1.0.0
 */
fun <E, K, V> Sequence<E>.associate(key: Transformer<E, K>, value: Transformer<E, V>) =
    associate { key(it) to value(it) }

/**
 * Populates the given [destination] mutable map with key-value pairs where keys and values are provided
 * by the [key] and [value] functions applied to elements of the sequence.
 *
 * The sequence is iterated to generate pairs, which are then added to the [destination] map.
 *
 * @param destination The mutable map to which the generated key-value pairs will be added.
 * @param key A function that computes a key from an element of the sequence.
 * @param value A function that computes a value from an element of the sequence.
 * @param E The type of the elements in the sequence.
 * @param K The type of the keys in the map.
 * @param V The type of the values in the map.
 * @param M The type of the destination mutable map (or a supertype of it).
 * @since 1.0.0
 */
fun <E, K, V, M : MutableMap<in K, in V>> Sequence<E>.associateTo(
    destination: M,
    key: Transformer<E, K>,
    value: Transformer<E, V>
) = associateTo(destination) { key(it) to value(it) }

/**
 * Invokes the integer to either take a specified number of elements from the sequence
 * if the integer is positive, or drop a specified number of elements when the integer is negative.
 *
 * @param sequence the sequence of elements to be acted upon.
 * @return a new sequence with elements taken or dropped based on the integer value.
 * @since 1.0.0
 */
operator fun <T> Int.invoke(sequence: Sequence<T>): Sequence<T> {
    return if (this > 0) sequence.take(this)
    else sequence.drop(-this)
}

/**
 * Merges the current sequence with additional sequences and returns the resulting sequence.
 * 
 * If the current sequence is null or empty and no additional sequences are provided, 
 * it returns an empty sequence. If additional sequences are provided, merges them iteratively.
 *
 * @param sequences Additional sequences to be merged with the current sequence.
 * @return A merged sequence containing elements from the current sequence and the additional sequences.
 * @since 1.0.0
 */
@Suppress("UNCHECKED_CAST")
fun <T: Sequence<E>, E> T?.merge(vararg sequences: Sequence<E>): T {
    return when {
        sequences.isEmpty() && (isNull() || none()) -> emptySequence<E>() as T
        sequences.isEmpty() -> this as T
        isNull() || none() -> sequences.first().merge(*sequences.drop(1).toTypedArray()) as T
        else -> sequences.fold(this) { acc, sequence -> acc.plus(sequence) as T }
    }
}

/**
 * Checks if the sequence contains any of the specified elements.
 *
 * This function evaluates lazily and stops as soon as any element in the sequence
 * matches one of the provided elements. The function uses the `in` operator internally
 * to check membership.
 *
 * @param elements the elements to be checked against the sequence.
 * @since 1.0.0
 */
fun <E> Sequence<E>.containsAny(vararg elements: E) = any { it in elements }

/**
 * Checks if none of the elements in the sequence are present in the specified elements.
 *
 * @param elements The elements to check against the sequence.
 * @return `true` if none of the elements in the sequence are present in the specified elements, `false` otherwise.
 * @since 1.0.0
 */
fun <E> Sequence<E>.containsNone(vararg elements: E) = none { it in elements }

/**
 * Returns the first element of the sequence or throws an exception provided by the given lazy exception supplier
 * if the sequence is empty.
 *
 * @param lazyException A supplier function that provides the exception to throw when the sequence is empty.
 * @return The first element of the sequence.
 * @since 1.0.0
 */
infix fun <E> Sequence<E>.firstOrThrow(lazyException: ThrowableSupplier): E = firstOrNull() ?: throw lazyException()
/**
 * Returns the first element of the sequence that matches the given [predicate].
 * If no elements match the [predicate], the exception provided by [lazyException] is thrown.
 *
 * @param lazyException A supplier that provides the exception to be thrown if no element matches the [predicate].
 * @param predicate A condition to be applied to each element to determine if it matches.
 * @return The first element that matches the [predicate].
 * @throws Throwable If no element matching the [predicate] is found.
 * @since 1.0.0
 */
fun <E> Sequence<E>.firstOrThrow(lazyException: ThrowableSupplier, predicate: Predicate<E>): E = firstOrNull(predicate) ?: throw lazyException()

/**
 * Returns the first element of the sequence or the result of [default] if the sequence is empty.
 *
 * @param default a supplier function that provides a value to return if the sequence is empty.
 * @since 1.0.0
 */
infix fun <E> Sequence<E>.firstOr(default: Supplier<E>) = firstOrNull() ?: default()
/**
 * Returns the first element in the sequence that matches the given [predicate].
 * If no such element is found, returns the result of calling the [default] supplier.
 *
 * @param E the type of elements in the sequence
 * @param default a supplier function that provides a default value if no element matches the [predicate]
 * @param predicate a function that defines the condition to match the elements in the sequence
 * @return the first element matching the [predicate], or the result of the [default] supplier if no match is found
 *
 * @since 1.0.0
 */
fun <E> Sequence<E>.firstOr(default: Supplier<E>, predicate: Predicate<E>) = firstOrNull(predicate) ?: default()

/**
 * Iterates through each element in the sequence and applies the specified action.
 * The iteration can be interrupted using a custom mechanism that supports returning
 * a value through the `Break` or `Continue` exceptions.
 *
 * @param action the action to be performed on each element of the sequence
 * @return the result value of type `R` if provided via the custom `Break` or `Continue` exception,
 *         or `null` if no value is provided
 * @since 1.0.0
 */
@Suppress("UNCHECKED_CAST")
fun <E, R> Sequence<E>.forEachWithReturn(action: ReceiverBiConsumer<LoopContext, E>): R? {
    with(LoopContext()) {
        for (element in this@forEachWithReturn) {
            try {
                action(element)
            } catch (b: Break) {
                return b.result as? R
            } catch (c: Continue) {
                continue
            }
        }
    }
    return null
}

/**
 * Iterates through each element of the sequence with its index, invoking the given action.
 * The iteration can be interrupted with a custom result using `Break` or skipped with `Continue`.
 *
 * @param action the action to perform on each element, receiving the index and the element as parameters
 * @return a result of type R if a `Continue` is thrown during iteration; otherwise, returns null
 * @since 1.0.0
 */
@Suppress("UNCHECKED_CAST")
fun <E, R> Sequence<E>.forEachIndexedWithReturn(action: ReceiverTriConsumer<LoopContext, Int, E>): R? {
    with(LoopContext()) {
        for ((index, element) in withIndex()) {
            try {
                action(index, element)
            } catch (b: Break) {
                return b.result as? R
            } catch (c: Continue) {
                continue
            }
        }
    }
    return null
}

/**
 * Splits a sequence into chunks where each chunk ends when the given predicate evaluates to true for an element.
 *
 * @param predicate A function that takes an element of the sequence and returns true when a chunk should end.
 * @return A sequence of lists, where each list represents a chunk of the original elements partitioned by the predicate.
 * @since 1.0.0
 */
fun <E> Sequence<E>.chunkedWhile(predicate: Predicate<E>): Sequence<List<E>> = run {
    val result = mutableListOf<List<E>>()
    var current = mutableListOf<E>()
    for (e in this) {
        current += e
        if (predicate(e)) {
            result.add(current)
            current = mutableListOf()
        }
    }
    if (current.isNotEmpty()) result.add(current)
    return result.asSequence()
}

/**
 * Repeats each element of the sequence a specified number of times and returns the resulting sequence.
 *
 * @param n The number of times each element of the sequence should be repeated. Must be a non-negative integer.
 * @since 1.0.0
 */
infix fun <E> Sequence<E>.repeatEach(n: Int) = flatMap { e -> e.asSingleList() * n }

/**
 * Returns the single element of the sequence if it contains exactly one element.
 *
 * Throws a [NoSuchElementException] if the sequence is empty.
 * Throws a [TooManyElementsException] if the sequence contains more than one element.
 *
 * @throws NoSuchElementException if the sequence is empty.
 * @throws TooManyElementsException if the sequence contains more than one element.
 * @receiver Sequence<E> The sequence to retrieve the single element from.
 * @return The only element in the sequence.
 * @since 1.0.0
 */
fun <E> Sequence<E>.onlyElement() = run {
    if (none()) throw NoSuchElementException()
    else if (singleOrNull().isNotNull()) single() else throw TooManyElementsException()
}
/**
 * Returns the single element of the sequence if it contains exactly one element, or `null` if the sequence is empty
 * or contains more than one element.
 *
 * This function terminates as soon as it can determine the result: it will stop processing further elements once
 * the second element is encountered if the sequence has more than one.
 *
 * It is equivalent to calling [singleOrNull] but provides clear intent when used in cases where you expect the
 * sequence to have zero or one element.
 *
 * @receiver The sequence to evaluate.
 * @return The single element if the sequence contains exactly one element, or `null` otherwise.
 * @since 1.0.0
 */
fun <E> Sequence<E>.onlyElementOrNull() = singleOrNull()
/**
 * Returns the single element of this sequence if it contains exactly one element, or the result of the provided
 * default supplier if the sequence is empty or contains more than one element.
 *
 * @param default A supplier function that provides a default value if the sequence is either empty or has more
 * than one element.
 * @since 1.0.0
 */
infix fun <E> Sequence<E>.onlyElementOr(default: Supplier<E>) = singleOrNull() ?: default()
/**
 * Returns the only element of the sequence or throws an exception provided by the given supplier
 * if the sequence contains zero or more than one element.
 *
 * @param lazyException A supplier function that provides the exception to be thrown if the sequence
 * does not contain exactly one element.
 * @since 1.0.0
 */
infix fun <E> Sequence<E>.onlyElementOrThrow(lazyException: ThrowableSupplier) = singleOrNull() ?: throw lazyException()
/**
 * Returns the only element in the sequence that matches the given predicate.
 * Throws an exception if there are no elements in the sequence, if no elements
 * match the predicate, or if more than one element matches the predicate.
 *
 * @param predicate A lambda function that defines the condition to match the desired element in the sequence.
 * @throws NoSuchElementException if the sequence is empty.
 * @throws TooManyElementsException if more than one element matches the predicate.
 * @throws NoSuchElementException if no elements match the predicate.
 * @since 1.0.0
 */
infix fun <E> Sequence<E>.onlyElement(predicate: Predicate<E>) = run {
    if (none()) throw NoSuchElementException()
    else if (singleOrNull(predicate).isNotNull()) single() else throw TooManyElementsException()
}
/**
 * Returns the single element of the sequence that matches the given [predicate], or `null` if no such element was found.
 * If more than one element matches the [predicate], an exception will be thrown.
 *
 * @param predicate A function that defines the condition to match the element.
 * @return The single element matching the [predicate], or `null` if no matching element is found.
 * @throws IllegalArgumentException if more than one element matches the [predicate].
 * @since 1.0.0
 */
infix fun <E> Sequence<E>.onlyElementOrNull(predicate: Predicate<E>) = singleOrNull(predicate)
/**
 * Returns the single element of this sequence that matches the given [predicate], or the value
 * provided by [default] if no such element is found.
 *
 * The operation will throw an exception if there is more than one matching element.
 *
 * @param default a supplier providing the fallback value if no element matches the [predicate]
 * @param predicate a predicate to determine the element that should be returned
 * @since 1.0.0
 */
fun <E> Sequence<E>.onlyElementOr(default: Supplier<E>, predicate: Predicate<E>) = singleOrNull(predicate) ?: default()
/**
 * Returns the single element of the sequence matching the given [predicate], or throws the exception provided
 * by the [lazyException] if no such element exists or if more than one element matches the [predicate].
 *
 * @param lazyException a supplier for the exception to be thrown when no element or multiple elements match the predicate
 * @param predicate a condition that the element needs to satisfy
 * @since 1.0.0
 */
fun <E> Sequence<E>.onlyElementOrThrow(lazyException: ThrowableSupplier, predicate: Predicate<E>) = singleOrNull(predicate) ?: throw lazyException()

/**
 * Checks if the sequence is empty.
 *
 * This function evaluates whether the sequence contains no elements.
 * It returns `true` if the sequence is empty, and `false` otherwise.
 *
 * Note that this function evaluates the sequence. Be cautious when using
 * it with potentially infinite sequences, as it might result in infinite execution.
 *
 * @receiver Sequence<E> the sequence to be checked.
 * @return `true` if the sequence contains no elements, `false` otherwise.
 * @since 1.0.0
 */
fun <E> Sequence<E>.isEmpty() = none()
/**
 * Checks if the sequence is not empty.
 *
 * This function evaluates the sequence to determine if it contains at least one element.
 * It is a terminal operation that consumes elements of the sequence if it is not empty.
 *
 * @receiver The sequence to check.
 * @return `true` if the sequence contains at least one element, `false` otherwise.
 * @since 1.0.0
 */
fun <E> Sequence<E>.isNotEmpty() = any()

/**
 * Checks if the given sequence is either `null` or empty.
 *
 * This function uses a contract to indicate that when it returns `false`, the sequence is guaranteed to be non-null.
 *
 * @return `true` if the sequence is `null` or contains no elements; otherwise `false`.
 * @since 1.0.0
 */
@OptIn(ExperimentalContracts::class)
@Suppress("kutils_null_check")
fun <E> Sequence<E>?.isNullOrEmpty(): Boolean {
    contract {
        returns(false) implies (this@isNullOrEmpty != null)
    }
    return isNull() || none()
}
/**
 * Checks if the given sequence is not null and not empty.
 *
 * @return `true` if the sequence is not null and contains at least one element, otherwise `false`.
 * @since 1.0.0
 */
@OptIn(ExperimentalContracts::class)
@Suppress("kutils_null_check")
fun <E> Sequence<E>?.isNotNullOrEmpty(): Boolean {
    contract {
        returns(true) implies (this@isNotNullOrEmpty != null)
    }
    return isNotNull() && any()
}

/**
 * Determines whether the sequence contains exactly one element.
 *
 * @return `true` if the sequence has exactly one element, otherwise `false`.
 * @since 1.0.0
 */
val  <E> Sequence<E>.isSingleElement: Boolean get() = singleOrNull().isNotNull()
/**
 * Checks if the sequence does not contain exactly one element.
 *
 * This function determines whether the sequence either has no elements
 * or contains more than one element.
 *
 * @return `true` if the sequence does not contain exactly one element,
 * `false` if it contains exactly one element.
 * @since 1.0.0
 */
val <E> Sequence<E>.isNotSingleElement: Boolean get() = !isSingleElement

/**
 * Returns the original sequence if it is neither null nor empty; otherwise, it invokes the
 * specified [defaultValue] supplier and returns its result.
 *
 * This function uses a contract to ensure that the [defaultValue] supplier is invoked at most once.
 *
 * @param defaultValue a supplier function that provides a replacement sequence in case the
 *                     original sequence is null or empty
 * @return the original sequence if it's not null or empty; otherwise, the result of the [defaultValue] supplier
 * @since 1.0.0
 */
@OptIn(ExperimentalContracts::class)
inline infix fun <S : Sequence<E>, E> S?.ifNullOrEmpty(defaultValue: Supplier<S>): S {
    contract {
        callsInPlace(defaultValue, InvocationKind.AT_MOST_ONCE)
    }
    return if (isNullOrEmpty()) defaultValue() else this
}

/**
 * Checks if the sequence is null or empty. The operator function `not` is used as a negation
 * to verify whether the sequence contains any elements or exists at all.
 *
 * @return `true` if the sequence is either null or empty, `false` otherwise.
 * @since 1.0.0
 */
@Suppress("kutils_null_check")
@OptIn(ExperimentalContracts::class)
operator fun <E> Sequence<E>?.not(): Boolean {
    contract {
        returns(false) implies (this@not != null)
    }
    return isNullOrEmpty()
}

/**
 * Divides the elements of a sequence into two groups based on a given predicate.
 * The result is a pair of lists, where the first list contains elements
 * that satisfy the predicate, and the second list contains elements that do not.
 *
 * @param predicate The condition to partition the elements of the sequence.
 * @return A pair of lists where the first list contains elements satisfying the predicate
 *         and the second list contains the remaining elements.
 * @since 1.0.0
 */
operator fun <E> Sequence<E>.div(predicate: Predicate<E>) = partition(predicate)
/**
 * Splits the elements of the sequence into lists each not exceeding the specified chunk size.
 *
 * The resulting sequence contains lists which group the original sequence's elements.
 * Each list will have a size of at most `chunkSize`. If the number of elements in
 * the sequence is not evenly divisible by `chunkSize`, then the last list in the resulting
 * sequence will contain the remaining elements.
 *
 * @param chunkSize the maximum number of elements in each chunked list.
 * @return a sequence of lists, where each list contains at most `chunkSize` elements.
 * @since 1.0.0
 */
operator fun <E> Sequence<E>.rem(chunkSize: Int): Sequence<List<E>> = chunked(chunkSize)
/**
 * Applies a partitioning operation on the sequence, grouping its elements into continuous chunks
 * that satisfy or do not satisfy the given predicate. The resulting sequence contains lists of elements,
 * where each list corresponds to a chunk determined by the changes in the predicate's condition.
 *
 * @param predicate a function that determines the condition applied to each element in the sequence.
 * @return a sequence of lists, where each list is a chunk of elements based on the predicate.
 * @since 1.0.0
 */
operator fun <E> Sequence<E>.rem(predicate: Predicate<E>): Sequence<List<E>> = chunkedWhile(predicate)

/**
 * Retrieves a subsequence of elements from the original sequence within the specified range.
 *
 * The method drops elements before the start of the range (inclusive) and
 * takes elements up to the end of the range (exclusive) from the sequence.
 *
 * @param T the type of elements in the sequence
 * @param range the range specifying the indices to extract; the start is inclusive, and the end is exclusive
 * @return a sequence containing the elements within the specified range
 * @since 1.0.0
 */
operator fun <T> Sequence<T>.get(range: IntRange) = drop(range.first)
    .take(range.last - range.first + 1)

/**
 * Retrieves an element at the specified index from the sequence.
 *
 * This function skips the specified number of elements in the sequence and then
 * returns the first element encountered. It is useful for random access in a sequence.
 *
 * Note that using this function on a sequence is not efficient for large indices, as it
 * involves iterating through elements sequentially until the specified position is reached.
 *
 * @param int The zero-based index of the element to retrieve from the sequence.
 * @return The element at the specified position in the sequence.
 * @throws NoSuchElementException If the specified index is beyond the bounds of the sequence.
 * @since 1.0.0
 */
operator fun <T> Sequence<T>.get(int: Int) = drop(int).first()

/**
 * Retrieves an element at the specified index from the sequence or returns null
 * if an exception is encountered during the operation.
 *
 * This function combines the behavior of the `get` function and `tryOrNull` to safely
 * access elements by index in a sequence. If the index is out of bounds or another
 * exception occurs, it will return null instead of throwing an exception.
 *
 * Note that accessing elements by index in a sequence is not efficient for large
 * indices, as it involves sequential iteration through the elements.
 *
 * @param T the type of elements in the sequence
 * @param index the zero-based index of the element to retrieve
 * @return the element at the specified index, or null if an exception occurs
 * @since 1.0.0
 */
infix fun <T> Sequence<T>.getOrNull(index: Int) = tryOrNull { get(index) }

/**
 * Retrieves the element at the specified index from a sequence or throws a custom exception if the index
 * is out of bounds.
 *
 * This function attempts to return the element at the given index by traversing the sequence up to the specified
 * position. If the index is invalid (e.g., negative or exceeds the size of the sequence), a custom exception
 * provided by the `lazyException` supplier is thrown.
 *
 * @param index The zero-based index of the element to retrieve from the sequence.
 * @param lazyException A supplier that provides the exception to be thrown if the element at the specified index
 * cannot be retrieved. By default, a `NoSuchElementException` is thrown with a message indicating the invalid index.
 * @return The element of the sequence at the specified index.
 * @throws Throwable The exception provided by `lazyException` if the index is invalid or if an error occurs during
 * the sequence traversal.
 *
 * @since 1.0.0
 */
fun <E> Sequence<E>.getOrThrow(index: Int, lazyException: ThrowableSupplier = { NoSuchElementException("Index $index not present") }): E =
    tryOrThrow(lazyException) { take(index).first() }

/**
 * Sorts the elements of the sequence based on the specified sorting direction.
 *
 * @param direction The sorting direction to apply. Use `SortingDirection.ASCENDING` to sort
 * in ascending order or `SortingDirection.DESCENDING` to sort in descending order.
 * @since 1.0.0
 */
fun <E: Comparable<E>> Sequence<E>.sorted(direction: SortDirection) = when (direction) {
    SortDirection.ASCENDING -> sorted()
    SortDirection.DESCENDING -> sortedDescending()
}

/**
 * Sorts elements in the sequence based on the specified sorting direction and a selector function.
 * Returns a sequence sorted in ascending or descending order as per the provided direction and selector.
 *
 * @param direction The direction to sort the sequence, either [SortDirection.ASCENDING] or [SortDirection.DESCENDING].
 * @param selector A lambda function to transform sequence elements into values used for sorting.
 *                 These values must be comparable or nullable comparable.
 * @since 1.0.0
 */
inline fun <E, R : Comparable<R>> Sequence<E>.sortedBy(direction: SortDirection, crossinline selector: Transformer<E, R?>) = when (direction) {
    SortDirection.ASCENDING -> sortedBy(selector)
    SortDirection.DESCENDING -> sortedByDescending(selector)
}

/**
 * Returns a subsequence of elements that appear before the given element in the sequence.
 * If the given element does not exist in the sequence, an empty sequence is returned.
 *
 * @param element the element in the sequence up to which the subsequence is returned, excluding the element itself.
 * @since 1.0.0
 */
infix fun <E> Sequence<E>.before(element: E) = if (contains(element)) get(0..<indexOf(element)) else emptySequence()
/**
 * Returns a new sequence of elements occurring before and including the first appearance of the specified element.
 * If the sequence does not contain the specified element, an empty sequence is returned.
 *
 * @param element The element to search for in the sequence. The resulting sequence includes elements
 *                from the start of the original sequence up to and including the first occurrence of this element.
 * @since 1.0.0
 */
infix fun <E> Sequence<E>.beforeIncluding(element: E) = if (contains(element)) get(0..indexOf(element)) else emptySequence()
/**
 * Returns a sequence containing elements of the original sequence that appear before the last occurrence
 * of the specified element. If the specified element is not found, an empty sequence is returned.
 *
 * @param element the element whose last occurrence is used as the boundary for creating the resulting sequence
 * @since 1.0.0
 */
infix fun <E> Sequence<E>.beforeLast(element: E) = if (contains(element)) get(0..<lastIndexOf(element)) else emptySequence()
/**
 * Returns a subsequence of elements from the beginning of the original sequence
 * up to and including the last occurrence of the specified [element].
 * If the [element] does not exist in the sequence, returns an empty sequence.
 *
 * @param element The element to locate within the sequence. The returned sequence
 * includes elements up to and including the last occurrence of this element.
 * @since 1.0.0
 */
infix fun <E> Sequence<E>.beforeLastIncluding(element: E) = if (contains(element)) get(0..lastIndexOf(element)) else emptySequence()
/**
 * Returns a sequence containing elements after the specified [element] in the original sequence.
 * If the [element] is not found in the sequence, returns an empty sequence.
 *
 * @param element the element after which the resulting sequence begins
 * @return a sequence of elements after the specified [element]
 * @since 1.0.0
 */
infix fun <E> Sequence<E>.after(element: E) = if (contains(element)) drop(indexOf(element) + 1) else emptySequence()
/**
 * Returns a sequence containing all elements of the original sequence starting from the first occurrence
 * of the specified element, including the element itself. If the element is not found, an empty sequence is returned.
 *
 * @param element the element from which to start the resulting sequence, inclusive.
 * @return a sequence starting from the specified element or an empty sequence if the element is not found.
 * @since 1.0.0
 */
infix fun <E> Sequence<E>.afterIncluding(element: E) = if (contains(element)) drop(indexOf(element)) else emptySequence()
/**
 * Creates a new sequence containing all elements after the last occurrence of the specified [element].
 * If the [element] is not present in the sequence, an empty sequence is returned.
 *
 * @param element The element after whose last occurrence the new sequence should start.
 * @since 1.0.0
 */
infix fun <E> Sequence<E>.afterLast(element: E) = if (contains(element)) drop(lastIndexOf(element) + 1) else emptySequence()
/**
 * Returns a sequence containing the elements of the original sequence after the last occurrence
 * of the specified [element], including the [element] itself. If the [element] is not present
 * in the sequence, an empty sequence is returned.
 *
 * @param element The element to search for in the sequence. The returned sequence starts
 * from the last occurrence of this element, including it.
 * @since 1.0.0
 */
infix fun <E> Sequence<E>.afterLastIncluding(element: E) = if (contains(element)) drop(lastIndexOf(element)) else emptySequence()

/**
 * Filters elements from the sequence by applying the provided transformer function and
 * checking if the result of the transformation is not null.
 *
 * @param element A transformer function that maps an element of the sequence to another value,
 * which is then checked for nullability.
 * @since 1.0.0
 */
infix fun <E, R> Sequence<E>.filterNotNull(element: Transformer<E, R>) =
    filter { element(it).isNotNull() }

/**
 * Filters elements from the sequence by applying the provided transformer function and
 * checking if the result of the transformation is null.
 *
 * @param element A transformer function that maps an element of the sequence to another value,
 * which is then checked for nullability.
 * @since 1.0.0
 */
infix fun <E, R> Sequence<E>.filterNull(element: Transformer<E, R>) =
    filter { element(it).isNull() }

/**
 * Allows performing the specified [action] on each element of the sequence without 
 * modifying the sequence itself. This is useful for actions such as logging or debugging.
 *
 * The operation is intermediate and does not consume the sequence.
 *
 * @param action the action to be performed on each element of the sequence.
 * @return the original sequence after applying the action to each element.
 * @since 1.0.0
 */
infix fun <I : Sequence<E>, E> I.peek(action: Consumer<E>) = apply { forEach(action) }